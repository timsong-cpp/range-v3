<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Range-v3: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Range-v3
   </div>
   <div id="projectbrief">Range algorithms, views, and actions for the Standard Library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial-preface">Preface</a><ul><li class="level2"><a href="#tutorial-installation">Installation</a></li>
<li class="level2"><a href="#tutorial-license">License</a></li>
<li class="level2"><a href="#tutorial-compilers">Supported Compilers</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-quick-start">Quick Start</a></li>
<li class="level1"><a href="#range-views">Range Views</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tutorial-preface"></a>
Preface</h1>
<hr/>
<p> Range library for C++11/14/17. This code is the basis of <a href="https://ericniebler.github.io/std/wg21/D4128.html">a formal proposal</a> to add range support to the C++ standard library.</p>
<p><b>Development Status:</b></p>
<p>This code is fairly stable, well-tested, and suitable for casual use, although currently lacking documentation. No promise is made about support or long-term stability. This code <em>will</em> evolve without regard to backwards compatibility.</p>
<h2><a class="anchor" id="tutorial-installation"></a>
Installation</h2>
<hr/>
<p> This library is header-only. You can get the source code from the <a href="https://github.com/ericniebler/range-v3">range-v3 repository</a> on github. To compile with Range-v3, you can either <code>#include</code> the entire library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">range/v3/all.hpp</a>&gt;</span></div>
</div><!-- fragment --><p>Or you can <code>#include</code> only the core, and then the individual headers you want:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_8hpp.html">range/v3/core.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;range/v3/....</span></div>
</div><!-- fragment --><h2><a class="anchor" id="tutorial-license"></a>
License</h2>
<hr/>
<p> Most of the source code in this project are mine, and those are under the Boost Software License. Parts are taken from Alex Stepanov's Elements of Programming, Howard Hinnant's libc++, and from the SGI STL. Please see the attached LICENSE file and the CREDITS file for the licensing and acknowledgements.</p>
<h2><a class="anchor" id="tutorial-compilers"></a>
Supported Compilers</h2>
<hr/>
<p> The code is known to work on the following compilers:</p>
<ul>
<li>clang 3.4.0</li>
<li>GCC 4.9.0</li>
</ul>
<h1><a class="anchor" id="tutorial-quick-start"></a>
Quick Start</h1>
<hr/>
<p> Range v3 is a generic library that augments the existing standard library with facilities for working with <em>ranges</em>. A range can be loosely thought of a pair of iterators, although they need not be implemented that way. Bundling begin/end iterators into a single object brings several benefits.</p>
<h2>Why Use Ranges?</h2>
<h3>Convenience</h3>
<p>It's more convenient to pass a single range object to an algorithm than separate begin/end iterators. Compare:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v{<span class="comment">/*...*/</span>};</div>
<div class="line"><a class="code" href="group__transformation.html#gab460e9dcd1e6286afd17421242b2adfb">std::sort</a>( v.begin(), v.end() );</div>
</div><!-- fragment --><p>with</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v{<span class="comment">/*...*/</span>};</div>
<div class="line"><a class="code" href="group__transformation.html#gab460e9dcd1e6286afd17421242b2adfb">ranges::sort</a>( v );</div>
</div><!-- fragment --><p>Range v3 contains a full implementation of all the standard algorithms with range-based overloads for convenience.</p>
<h3>Composability</h3>
<p>Having a single range object permits <em>pipelines</em> of operations. In a pipeline, a range is lazily adapted or eagerly mutated in some way, with the result immediately available for further adaptation or mutation. Lazy adaption is handled by <em>views</em>, and eager mutation is handled by <em>actions</em>.</p>
<h4>Views</h4>
<p>A view is a lightweight wrapper that presents a view of an underlying sequence of elements in some custom way without mutating or copying it. Views are cheap to create and copy, and have non-owning reference semantics. Below are some examples:</p>
<p>Filter a container using a predicate and transform it.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vi{1,2,3,4,5,6,7,8,9,10};</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line"><span class="keyword">auto</span> rng = vi | <a class="code" href="group__group-actions.html#ga673f1edcd5ad49303d37605d71b52e0e">view::remove_if</a>([](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> i % 2 == 1;})</div>
<div class="line">              | <a class="code" href="group__transformation.html#ga1232449533420b49364f2b3a27154cc3">view::transform</a>([](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> std::to_string(i);});</div>
<div class="line"><span class="comment">// rng == {&quot;2&quot;,&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;10&quot;};</span></div>
</div><!-- fragment --><p>Generate an infinite list of integers starting at 1, square them, take the first 10, and sum them:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line"><span class="keywordtype">int</span> sum = <a class="code" href="group__transformation.html#ga9ca974f63ad4bb43802cf68d3c83bb8f">accumulate</a>(view::ints(1)</div>
<div class="line">                   | <a class="code" href="group__transformation.html#ga1232449533420b49364f2b3a27154cc3">view::transform</a>([](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> i*i;})</div>
<div class="line">                   | view::take(10), 0);</div>
</div><!-- fragment --><p>Generate a sequence on the fly with a range comprehension and initialize a vector with it:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line">std::vector&lt;int&gt; vi =</div>
<div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">view::for_each</a>(view::ints(1,10), [](<span class="keywordtype">int</span> i){</div>
<div class="line">        <span class="keywordflow">return</span> yield_from(<a class="code" href="group__list.html#gab4b5da3947303335fc4139f163ed4748">view::repeat_n</a>(i,i));</div>
<div class="line">    });</div>
<div class="line"><span class="comment">// vi == {1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,...}</span></div>
</div><!-- fragment --><h4>Actions</h4>
<p>When you want to mutate a container in-place, or forward it through a chain of mutating operations, you can use actions. The following examples should make it clear.</p>
<p>Read data into a vector, sort it, and make it unique.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> std::vector&lt;int&gt; read_data();</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line">std::vector&lt;int&gt; vi = read_data() | <a class="code" href="group__transformation.html#gab460e9dcd1e6286afd17421242b2adfb">action::sort</a> | <a class="code" href="group__transformation.html#gadf83711e56c6bc24311aa68b338cac7d">action::unique</a>;</div>
</div><!-- fragment --><p>Do the same to a <code>vector</code> that already contains some data:</p>
<div class="fragment"><div class="line">vi = <a class="code" href="group__group-algorithms.html#gad3830f80a601a6a46958ca50ef2e34c5">std::move</a>(vi) | <a class="code" href="group__transformation.html#gab460e9dcd1e6286afd17421242b2adfb">action::sort</a> | <a class="code" href="group__transformation.html#gadf83711e56c6bc24311aa68b338cac7d">action::unique</a>;</div>
</div><!-- fragment --><p>Mutate the container in-place:</p>
<div class="fragment"><div class="line">vi |= <a class="code" href="group__transformation.html#gab460e9dcd1e6286afd17421242b2adfb">action::sort</a> | <a class="code" href="group__transformation.html#gadf83711e56c6bc24311aa68b338cac7d">action::unique</a>;</div>
</div><!-- fragment --><p>Same as above, but with function-call syntax instead of pipe syntax:</p>
<div class="fragment"><div class="line"><a class="code" href="group__transformation.html#gadf83711e56c6bc24311aa68b338cac7d">action::unique</a>(<a class="code" href="group__transformation.html#gab460e9dcd1e6286afd17421242b2adfb">action::sort</a>(vi));</div>
</div><!-- fragment --><h2>Create Custom Ranges</h2>
<p>Range v3 provides a utility for easily creating your own range types, called <code>view_facade</code>. The code below uses <code>view_facade</code> to create a range that traverses a null-terminated string:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">range/v3/all.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceranges.html">ranges</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// A range that iterates over all the characters in a</span></div>
<div class="line"><span class="comment">// null-terminated string.</span></div>
<div class="line"><span class="keyword">class </span>c_string_range</div>
<div class="line">  : <span class="keyword">public</span> view_facade&lt;c_string_range&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">friend</span> range_access;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> * sz_;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> &amp; <span class="keyword">get</span>() <span class="keyword">const</span> { <span class="keywordflow">return</span> *sz_; }</div>
<div class="line">    <span class="keywordtype">bool</span> done()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *sz_ == <span class="charliteral">&#39;\0&#39;</span>; }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__group-utility.html#ga70320521358b8e16455a2931d524bab9">next</a>() { ++sz_; }</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    c_string_range() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">explicit</span> c_string_range(<span class="keywordtype">char</span> <span class="keyword">const</span> *sz) : sz_(sz)</div>
<div class="line">    {</div>
<div class="line">        assert(sz != <span class="keyword">nullptr</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>view_facade</code> class generates an iterator and begin/end member functions from the minimal interface provided by <code>c_string_range</code>. This is an example of a very simple range for which it is not necessary to separate the range itself from the thing that iterates the range. Future examples will show examples of more sophisticated ranges.</p>
<p>With <code>c_string_range</code>, you can now use algorithms to operate on null-terminated strings, as below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    c_string_range r(<span class="stringliteral">&quot;hello world&quot;</span>);</div>
<div class="line">    <span class="comment">// Iterate over all the characters and print them out</span></div>
<div class="line">    <a class="code" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03">ranges::for_each</a>(r, [](<span class="keywordtype">char</span> ch){</div>
<div class="line">        std::cout &lt;&lt; ch &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    });</div>
<div class="line">    <span class="comment">// prints: h e l l o   w o r l d</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Adapting Ranges</h2>
<p>Often, a new range type is most easily expressed by adapting an existing range type. That's the case for many of the range views provided by the Range v3 library; for example, the <code>view::remove_if</code> and <code>view::transform</code> views. These are rich types with many moving parts, but thanks to a helper class called <code>view_adaptor</code>, they aren't hard to write.</p>
<p>Below in roughly 2 dozen lines of code is the <code>transform</code> view, which takes one range and transforms all the elements with a unary function.</p>
<div class="fragment"><div class="line"><span class="comment">// A class that adapts an existing range with a function</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rng, <span class="keyword">class</span> Fun&gt;</div>
<div class="line"><span class="keyword">class </span>transform_view : <span class="keyword">public</span> view_adaptor&lt;transform_view&lt;Rng, Fun&gt;, Rng&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">friend</span> range_access;</div>
<div class="line">    semiregular_t&lt;Fun&gt; fun_; <span class="comment">// Make Fun model SemiRegular if it doesn&#39;t</span></div>
<div class="line">    <span class="keyword">class </span>adaptor : <span class="keyword">public</span> adaptor_base</div>
<div class="line">    {</div>
<div class="line">        semiregular_t&lt;Fun&gt; fun_;</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        adaptor() = <span class="keywordflow">default</span>;</div>
<div class="line">        adaptor(semiregular_t&lt;Fun&gt; <span class="keyword">const</span> &amp;fun) : fun_(fun) {}</div>
<div class="line">        <span class="comment">// Here is where we apply Fun to the elements:</span></div>
<div class="line">        <span class="keyword">auto</span> <span class="keyword">get</span>(range_iterator_t&lt;Rng&gt; it) <span class="keyword">const</span> -&gt; decltype(fun_(*it))</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> fun_(*it);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    adaptor begin_adaptor()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {fun_}; }</div>
<div class="line">    adaptor end_adaptor()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> {fun_}; }</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    transform_view() = <span class="keywordflow">default</span>;</div>
<div class="line">    transform_view(Rng &amp;&amp; rng, Fun fun)</div>
<div class="line">      : transform_view::view_adaptor{std::forward&lt;Rng&gt;(rng)}</div>
<div class="line">      , fun_(<a class="code" href="group__group-algorithms.html#gad3830f80a601a6a46958ca50ef2e34c5">std::move</a>(fun))</div>
<div class="line">    {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rng, <span class="keyword">class</span> Fun&gt;</div>
<div class="line">transform_view&lt;Rng, Fun&gt; <a class="code" href="group__transformation.html#ga1232449533420b49364f2b3a27154cc3">transform</a>(Rng &amp;&amp; rng, Fun fun)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> {std::forward&lt;Rng&gt;(rng), <a class="code" href="group__group-algorithms.html#gad3830f80a601a6a46958ca50ef2e34c5">std::move</a>(fun)};</div>
<div class="line">}</div>
</div><!-- fragment --><p>Range transformation is achieved by defining a nested <code>adaptor</code> class that handles the transformation, and then defining <code>begin_adaptor</code> and <code>end_adaptor</code> members that return adaptors for the begin iterator and the end sentinel, respectively. The <code>adaptor</code> class has a <code>get</code> member that performs the transformation. It is passed an iterator to the current element. Other members are available for customization: <code>equal</code>, <code>next</code>, <code>prev</code>, <code>advance</code>, and <code>distance_to</code>; but the transform adaptor accepts the defaults defined in <code>adaptor_base</code>.</p>
<p>With <code>transform_view</code>, we can print out the first 20 squares:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> squares = <a class="code" href="group__group-actions.html#gaf9135baba87fb451e6e904428239ad19">::transform</a>(view::ints(1), [](<span class="keywordtype">int</span> i){<span class="keywordflow">return</span> i*i;});</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : squares | view::take(20))</div>
<div class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">    <span class="comment">// prints 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>transform_view</code> defined above is an InputRange when its wrapping an InputRange, a ForwardRange when its wrapping a ForwardRange, etc. That happens because of smart defaults defined in the <code>adaptor_base</code> class. That frees you from having to deal with a host of niggly detail when implementing iterators.</p>
<p>*(Note: the above <code>transform_view</code> always stores a copy of the function in the sentinel. That is only necessary if the underlying range's sentinel type models BidirectionalIterator. That's a finer point that you shouldn't worry about right now.)*</p>
<h2>Constrain Functions with Concepts</h2>
<p>The Range v3 library makes heavy use of concepts to constrain functions, control overloading, and check type constraints at compile-time. It achieves this with the help of a Concepts Lite emulation layer that works on any standard-conforming C++11 compiler. The library provides many useful concepts, both for the core language and for iterators and ranges. You can use the concepts framework to constrain your own code.</p>
<p>For instance, if you would like to write a function that takes an iterator/sentinel pair, you can write it like this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class </span>Iter, <span class="keyword">class </span>Sent, <span class="keyword">class </span>Comp = <span class="comment">/*...some_default..*/</span>,</div>
<div class="line">    CONCEPT_REQUIRES_(Sentinel&lt;Sent, Iter&gt;())&gt;</div>
<div class="line"><span class="keywordtype">void</span> my_algorithm(Iter <a class="code" href="group__list.html#ga68418643d5aacd0ec2afe5a0e933ccf3">first</a>, Sent last, Comp comp = Comp{})</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>You can then add an overload that take a Range:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class </span>Rng, <span class="keyword">class </span>Comp = <span class="comment">/*...some_default..*/</span>,</div>
<div class="line">    CONCEPT_REQUIRES_(Range&lt;Rng&gt;())&gt;</div>
<div class="line"><span class="keywordtype">void</span> my_algorithm(Rng &amp;&amp; rng, Comp comp = Comp{})</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> my_algorithm(<a class="code" href="group__group-core.html#ga5cd4d994f52574435adf4735ce3fd46b">ranges::begin</a>(rng), <a class="code" href="group__group-core.html#gad1b3568669864576b4f73d7032263620">ranges::end</a>(rng));</div>
<div class="line">}</div>
</div><!-- fragment --><p>With the type constraints expressed with the <code>CONCEPTS_REQUIRES_</code> macro, these two overloads are guaranteed to not be ambiguous.</p>
<h2>Range v3 and the Future</h2>
<p>Range v3 forms the basis for a proposal to add ranges to the standard library (<a href="www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html">N4128</a>), and will also be the basis for a Technical Specification on Ranges. Its design direction has already passed an initial review by the standardization committee. What that means is that you may see your compiler vendor shipping a library like Range v3 at some point in the future. That's the hope, anyway.</p>
<p>Enjoy!</p>
<h1><a class="anchor" id="range-views"></a>
Range Views</h1>
<hr/>
<p> The big advantage of ranges over iterators is their <em>composability</em>. They permit a functional style of programming where data is manipulated by passing it through a series of combinators. In addition, the combinators can be <em>lazy</em>, only doing work when the answer is requested, and <em>purely functional</em>, without mutating the original data. This makes it easier to reason about your code, especially when writing concurrent programs.</p>
<p>Below is a list of the lazy range combinators, or <em>views</em>, that Range v3 provides, and a blurb about how each is intended to be used.</p>
<dl>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1adjacent__filter__fn.html"><code>view::adjacent_filter</code></a> </dt>
<dd>For each pair of adjacent elements in a source range, evaluate the specified binary predicate. If the predicate evaluates to false, the second element of the pair is removed from the result range; otherwise, it is included. The first element in the source range is always included. (For instance, <code>adjacent_filter</code> with <code>std::not_equal_to</code> filters out all the non-unique elements.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1adjacent__remove__if__fn.html"><code>view::adjacent_remove_if</code></a> </dt>
<dd>For each pair of adjacent elements in a source range, evaluate the specified binary predicate. If the predicate evaluates to true, the first element of the pair is removed from the result range; otherwise, it is included. The last element in the source range is always included. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1all__fn.html"><code>view::all</code></a> </dt>
<dd>Return a range containing all the elements in the source. Useful for converting containers to ranges. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1bounded__fn.html"><code>view::bounded</code></a> </dt>
<dd>Convert the source range to a <em>bounded</em> range, where the type of the <code>end</code> is the same as the <code>begin</code>. Useful for iterating over a range with C++'s range-based <code>for</code> loop. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1chunk__fn.html"><code>view::chunk</code></a> </dt>
<dd>Given a source range and an integer <em>N</em>, produce a range of contiguous ranges where each inner range has <em>N</em> contiguous elements. The final range may have fewer than <em>N</em> elements. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1concat__fn.html"><code>view::concat</code></a> </dt>
<dd>Given <em>N</em> source ranges, produce a result range that is the concatenation of all of them. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1const__fn.html"><code>view::const_</code></a> </dt>
<dd>Present a <code>const</code> view of a source range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1counted__fn.html"><code>view::counted</code></a> </dt>
<dd>Given an iterator <code>it</code> and a count <code>n</code>, create a range that starts at <code>it</code> and includes the next <code>n</code> elements. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1delimit__fn.html"><code>view::delimit</code></a> </dt>
<dd>Given a source range and a value, return a new range that ends either at the end of the source or at the first occurrence of the value, whichever comes first. Alternatively, <code>view::delimit</code> can be called with an iterator and a value, in which case it returns a range that starts at the specified position and ends at the first occurrence of the value. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1drop__fn.html"><code>view::drop</code></a> </dt>
<dd>Given a source range and an integral count, return a range consisting of all but the first <em>count</em> elements from the source range, or an empty range if it has fewer elements. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1drop__exactly__fn.html"><code>view::drop_exactly</code></a> </dt>
<dd>Given a source range and an integral count, return a range consisting of all but the first <em>count</em> elements from the source range. The source range must have at least that many elements. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1drop__while__fn.html"><code>view::drop_while</code></a> </dt>
<dd>Remove elements from the front of a range that satisfy a unary predicate. </dd>
<dt><a class="el" href="group__list.html#gada7280d87ece1a3dc6b203ee0e86e71c"><code>view::empty</code></a> </dt>
<dd>Create an empty range with a given value type. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1generate__fn.html"><code>view::generate</code></a> </dt>
<dd>Given a nullary function, return an infinite range whose elements are generated with the function. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1generate__n__fn.html"><code>view::generate_n</code></a> </dt>
<dd>Given a nullary function and a count, return a range that generates the requested number of elements by calling the function. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1group__by__fn.html"><code>view::group_by</code></a> </dt>
<dd>Given a source range and a binary predicate, return a range of ranges where each range contains contiguous elements from the source range such that the following condition holds: for each element in the range apart from the first, when that element and the first element are passed to the binary predicate, the result is true. In essence, <code>view::group_by</code> <em>groups</em> contiguous elements together with a binary predicate. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1indirect__fn.html"><code>view::indirect</code></a> </dt>
<dd>Given a source range of readable values (e.g. pointers or iterators), return a new view that is the result of dereferencing each. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1intersperse__fn.html"><code>view::intersperse</code></a> </dt>
<dd>Given a source range and a value, return a new range where the value is inserted between contiguous elements from the source. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1ints__fn.html"><code>view::ints</code></a> </dt>
<dd>Generate a range of monotonically increasing <code>int</code>s. When used without arguments, it generates the quasi-infinite range [0,1,2,3...]. It can also be called with a lower bound, or with a lower and upper bound (exclusive). </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1iota__fn.html"><code>view::iota</code></a> </dt>
<dd>A generalization of <code>view::ints</code> that generates a sequence of monotonically increasing values of any incrementable type. When specified with a single argument, the result is an infinite range beginning at the specified value. With two arguments, the values are assumed to denote a half-open range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1join__fn.html"><code>view::join</code></a> </dt>
<dd>Given a range of ranges, join them into a flattened sequence of elements. Optionally, you can specify a value or a range to be inserted between each source range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1keys__fn.html"><code>view::keys</code></a> </dt>
<dd>Given a range of <code>pair</code>s (like a <code>std::map</code>), return a new range consisting of just the first element of the <code>pair</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1move__fn.html"><code>view::move</code></a> </dt>
<dd>Given a source range, return a new range where each element has been has been cast to an rvalue reference. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1partial__sum__fn.html"><code>view::partial_sum</code></a> </dt>
<dd>Given a range and a binary function, return a new range where the <em>N</em><sup>th</sup> element is the result of applying the function to the <em>N</em><sup>th</sup> element from the source range and the (N-1)th element from the result range. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1remove__if__fn.html"><code>view::remove_if</code></a> </dt>
<dd>Given a source range and a unary predicate, filter out those elements that do not satisfy the predicate. (For users of Boost.Range, this is like the <code>filter</code> adaptor with the predicate negated.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1repeat__fn.html"><code>view::repeat</code></a> </dt>
<dd>Given a value, create a range that is that value repeated infinitely. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1repeat__n__fn.html"><code>view::repeat_n</code></a> </dt>
<dd>Given a value and a count, create a range that is that value repeated <em>count</em> number of times. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1replace__fn.html"><code>view::replace</code></a> </dt>
<dd>Given a source range, a source value and a target value, create a new range where all elements equal to the source value are replaced with the target value. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1replace__if__fn.html"><code>view::replace_if</code></a> </dt>
<dd>Given a source range, a unary predicate and a target value, create a new range where all elements that satisfy the predicate are replaced with the target value. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1reverse__fn.html"><code>view::reverse</code></a> </dt>
<dd>Create a new range that traverses the source range in reverse order. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1single__fn.html"><code>view::single</code></a> </dt>
<dd>Given a value, create a range with exactly one element. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1slice__fn.html"><code>view::slice</code></a> </dt>
<dd>Give a source range a lower bound (inclusive) and an upper bound (exclusive), create a new range that begins and ends at the specified offsets. Both the begin and the end can be integers relative to the front, or relative to the end with "`end-2`" syntax. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1split__fn.html"><code>view::split</code></a> </dt>
<dd>Given a source range and a delimiter specifier, split the source range into a range of ranges using the delimiter specifier to find the boundaries. The delimiter specifier can be a value, a subrange, a predicate, or a function. The predicate should take an single argument of the range's reference type and return true if and only if the element is part of a delimiter. The function should accept current/end iterators into the source range and return <code>make_pair(true, iterator_past_the_delimiter)</code> if the current position is a boundary; otherwise, <code>make_pair(false, cur)</code>. The delimiter character(s) are excluded from the resulting range of ranges. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1stride__fn.html"><code>view::stride</code></a> </dt>
<dd>Given a source range and an integral stride value, return a range consisting of every <em>N</em><sup>th</sup> element, starting with the first. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1tail__fn.html"><code>view::tail</code></a> </dt>
<dd>Given a source range, return a new range without the first element. The range must have at least one element. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1take__fn.html"><code>view::take</code></a> </dt>
<dd>Given a source range and an integral count, return a range consisting of the first <em>count</em> elements from the source range, or the complete range if it has fewer elements. (The result of <code>view::take</code> is not a <code>SizedRange</code>.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1take__exactly__fn.html"><code>view::take_exactly</code></a> </dt>
<dd>Given a source range and an integral count, return a range consisting of the first <em>count</em> elements from the source range. The source range must have at least that many elements. (The result of <code>view::take_exactly</code> is a <code>SizedRange</code>.) </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1take__while__fn.html"><code>view::take_while</code></a> </dt>
<dd>Given a source range and a unary predicate, return a new range consisting of the elements from the front that satisfy the predicate. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1tokenize__fn.html"><code>view::tokenize</code></a> </dt>
<dd>Given a source range and optionally a submatch specifier and a <code>std::regex_constants::match_flag_type</code>, return a <code>std::regex_token_iterator</code> to step through the regex submatches of the source range. The submatch specifier may be either a plain <code>int</code>, a <code>std::vector&lt;int&gt;</code>, or a <code>std::initializer_list&lt;int&gt;</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1transform__fn.html"><code>view::transform</code></a> </dt>
<dd>Given a source range and a unary function, return a new range where each result element is the result of applying the unary function to a source element. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1unbounded__fn.html"><code>view::unbounded</code></a> </dt>
<dd>Given an iterator, return an infinite range that begins at that position. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1unique__fn.html"><code>view::unique</code></a> </dt>
<dd>Given a range, return a new range where all consecutive elements that compare equal save the first have been filtered out. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1values__fn.html"><code>view::values</code></a> </dt>
<dd>Given a range of <code>pair</code>s (like a <code>std::map</code>), return a new range consisting of just the second element of the <code>pair</code>. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1zip__fn.html"><code>view::zip</code></a> </dt>
<dd>Given <em>N</em> ranges, return a new range where <em>M</em><sup>th</sup> element is the result of calling <code>make_tuple</code> on the <em>M</em><sup>th</sup> elements of all <em>N</em> ranges. </dd>
<dt><a class="el" href="structranges_1_1v3_1_1view_1_1zip__with__fn.html"><code>view::zip_with</code></a> </dt>
<dd>Given <em>N</em> ranges and a <em>N</em>-ary function, return a new range where <em>M</em><sup>th</sup> element is the result of calling the function on the <em>M</em><sup>th</sup> elements of all <em>N</em> ranges. </dd>
</dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
